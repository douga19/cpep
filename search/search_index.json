{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Competitive Programming - Efrei Paris Annonces Solutions Coding Battle 2021 [4-octobre-2022] Bonjour \u00e0 tous, vous trouverez ici les solutions compl\u00e8tes, ou les indications pour r\u00e9soudre les probl\u00e8mes de la Coding Battle 2021. Lire la suite Coding Battle 2022 [5-septembre-2022] Bonjour \u00e0 tous j'esp\u00e8re que tout le monde a pass\u00e9 un bel \u00e9t\u00e9 et de bonnes vacances . Nous allons reprendre les s\u00e9ances de pr\u00e9parations pour le Shaker qui arrivera tr\u00e8s vite : les 12 et 13 octobre 2022. Lire la suite Coding Battle 2022 [11-juillet-2022] Bonjour \u00e0 tous \ud83d\ude42. La prochaine \u00e9ch\u00e9ance de l'\u00e9quipe arrive \u00e0 grand pas. Les 12 et 13 Octobre 2022 se d\u00e9rouleront la sixi\u00e8me \u00e9dition du Shaker et sa Coding Battle. Lire la suite Pr\u00e9sentation L'\u00e9quipe de programmation comp\u00e9titive s'adresse aux \u00e9tudiants d'Efrei Paris ayant signifi\u00e9 leur int\u00e9r\u00eats pour la programmation comp\u00e9titive. Cette \u00e9quipe a pour but de vous accompagner dans votre progression en mati\u00e8re de programmation comp\u00e9titive; mais \u00e9galement pour vous pr\u00e9parer au mieux pour les diff\u00e9rents concours de programmation. \u00c0 court terme, nous vous pr\u00e9parerons pour les concours nationaux : Prologin et la Coding Battle du Shaker . Cette page web nous servira pour partager les contenus et publier les challenges d'entra\u00eenements pour le projet. Au fur et \u00e0 mesure de notre avancement, cette page est susceptible d'\u00e9voluer. Pour toutes questions ou demandes, nous avons l'\u00e9quipe Teams . Structure de la page web Les annonces importantes sur le d\u00e9roulement du projet ainsi que les consignes \u00e0 suivre se feront dans la rubrique Annonces . Dans la rubrique Contenus , vous retrouverez les contenus de tout type que le projet va produire : notes pour les mini-cours th\u00e9matiques, les weekly challenges, les anciens sujets de concours. Organisation Nous allons essayer de nous organiser de la mani\u00e8re suivante : Se cr\u00e9er un compte et s'inscrire sur leetcode : Nous allons privil\u00e9gier cet online-judge pour les entra\u00eenements quotidiens. L'id\u00e9e est que chacun s'entra\u00eene r\u00e9guli\u00e8rement \u00e0 r\u00e9soudre des probl\u00e8mes sur leetcode. Des s\u00e9ances th\u00e9matiques seront planifi\u00e9es selon la disponibilit\u00e9 de chacun ( pr\u00e9sentiel ou distanciel ) : Ces s\u00e9ances seront sous forme de mini-cours sur une th\u00e9matique pr\u00e9cise. Ne voyez pas ces s\u00e9ances comme n\u00e9cessaires pour progresser, c'est-\u00e0-dire, attendre des s\u00e9ances pour vous entra\u00eener de votre c\u00f4t\u00e9 : l'id\u00e9e est de vous accompagner et non pas tout faire \u00e0 votre place. Un mini problem-set \u00e0 r\u00e9soudre chaque semaine (Weekly Challenge) : Trois probl\u00e8mes (facile - interm\u00e9diaire - avanc\u00e9). Les m\u00eames pour tout le monde pour \u00e9valuer la progression de chacun. Le premier se trouve ici . Mise en situation avec d'anciens sujets de concours ou comp\u00e9titions internes : Nous mettrons \u00e0 disposition d'anciens sujets de concours que vous devrez traiter soit de votre c\u00f4t\u00e9 soit dans de conditions r\u00e9elles. Choix du langage de programmation : Pour l'instant, chacun est libre de choisir le langage de programmation, bien qu'\u00e0 terme je souhaiterai que chacun code en C++ ( pourquoi ? pour son efficacit\u00e9 prouv\u00e9e et sa biblioth\u00e8que standard) Par o\u00f9 commencer ? Normalement chacun doit avoir un minimum de bagage en algorithmique et en programmation. Mais voici des liens utiles qui pourrons vous aider : Competitive Programmer's Handbook : un livre qui couvre \u00e0 peu pr\u00e8s toutes les bases de la programmation comp\u00e9titive. Visualgo : une sorte de Ctutor pour visualiser des algorithmes sous forme d'animation. leetcode : online judge pour les entra\u00eenements quotidiens, offre une section solution (mais pour votre bien, essayer d'abord par vous m\u00eame avant de regarder les solutions). kattis : online judge que l'on va utiliser pour les comp\u00e9titions internes.","title":"Accueil"},{"location":"#competitive-programming-efrei-paris","text":"","title":"Competitive Programming - Efrei Paris"},{"location":"#annonces","text":"Solutions Coding Battle 2021 [4-octobre-2022] Bonjour \u00e0 tous, vous trouverez ici les solutions compl\u00e8tes, ou les indications pour r\u00e9soudre les probl\u00e8mes de la Coding Battle 2021. Lire la suite Coding Battle 2022 [5-septembre-2022] Bonjour \u00e0 tous j'esp\u00e8re que tout le monde a pass\u00e9 un bel \u00e9t\u00e9 et de bonnes vacances . Nous allons reprendre les s\u00e9ances de pr\u00e9parations pour le Shaker qui arrivera tr\u00e8s vite : les 12 et 13 octobre 2022. Lire la suite Coding Battle 2022 [11-juillet-2022] Bonjour \u00e0 tous \ud83d\ude42. La prochaine \u00e9ch\u00e9ance de l'\u00e9quipe arrive \u00e0 grand pas. Les 12 et 13 Octobre 2022 se d\u00e9rouleront la sixi\u00e8me \u00e9dition du Shaker et sa Coding Battle. Lire la suite","title":"Annonces"},{"location":"#presentation","text":"L'\u00e9quipe de programmation comp\u00e9titive s'adresse aux \u00e9tudiants d'Efrei Paris ayant signifi\u00e9 leur int\u00e9r\u00eats pour la programmation comp\u00e9titive. Cette \u00e9quipe a pour but de vous accompagner dans votre progression en mati\u00e8re de programmation comp\u00e9titive; mais \u00e9galement pour vous pr\u00e9parer au mieux pour les diff\u00e9rents concours de programmation. \u00c0 court terme, nous vous pr\u00e9parerons pour les concours nationaux : Prologin et la Coding Battle du Shaker . Cette page web nous servira pour partager les contenus et publier les challenges d'entra\u00eenements pour le projet. Au fur et \u00e0 mesure de notre avancement, cette page est susceptible d'\u00e9voluer. Pour toutes questions ou demandes, nous avons l'\u00e9quipe Teams .","title":"Pr\u00e9sentation"},{"location":"#structure-de-la-page-web","text":"Les annonces importantes sur le d\u00e9roulement du projet ainsi que les consignes \u00e0 suivre se feront dans la rubrique Annonces . Dans la rubrique Contenus , vous retrouverez les contenus de tout type que le projet va produire : notes pour les mini-cours th\u00e9matiques, les weekly challenges, les anciens sujets de concours.","title":"Structure de la page web"},{"location":"#organisation","text":"Nous allons essayer de nous organiser de la mani\u00e8re suivante : Se cr\u00e9er un compte et s'inscrire sur leetcode : Nous allons privil\u00e9gier cet online-judge pour les entra\u00eenements quotidiens. L'id\u00e9e est que chacun s'entra\u00eene r\u00e9guli\u00e8rement \u00e0 r\u00e9soudre des probl\u00e8mes sur leetcode. Des s\u00e9ances th\u00e9matiques seront planifi\u00e9es selon la disponibilit\u00e9 de chacun ( pr\u00e9sentiel ou distanciel ) : Ces s\u00e9ances seront sous forme de mini-cours sur une th\u00e9matique pr\u00e9cise. Ne voyez pas ces s\u00e9ances comme n\u00e9cessaires pour progresser, c'est-\u00e0-dire, attendre des s\u00e9ances pour vous entra\u00eener de votre c\u00f4t\u00e9 : l'id\u00e9e est de vous accompagner et non pas tout faire \u00e0 votre place. Un mini problem-set \u00e0 r\u00e9soudre chaque semaine (Weekly Challenge) : Trois probl\u00e8mes (facile - interm\u00e9diaire - avanc\u00e9). Les m\u00eames pour tout le monde pour \u00e9valuer la progression de chacun. Le premier se trouve ici . Mise en situation avec d'anciens sujets de concours ou comp\u00e9titions internes : Nous mettrons \u00e0 disposition d'anciens sujets de concours que vous devrez traiter soit de votre c\u00f4t\u00e9 soit dans de conditions r\u00e9elles. Choix du langage de programmation : Pour l'instant, chacun est libre de choisir le langage de programmation, bien qu'\u00e0 terme je souhaiterai que chacun code en C++ ( pourquoi ? pour son efficacit\u00e9 prouv\u00e9e et sa biblioth\u00e8que standard)","title":"Organisation"},{"location":"#par-ou-commencer","text":"Normalement chacun doit avoir un minimum de bagage en algorithmique et en programmation. Mais voici des liens utiles qui pourrons vous aider : Competitive Programmer's Handbook : un livre qui couvre \u00e0 peu pr\u00e8s toutes les bases de la programmation comp\u00e9titive. Visualgo : une sorte de Ctutor pour visualiser des algorithmes sous forme d'animation. leetcode : online judge pour les entra\u00eenements quotidiens, offre une section solution (mais pour votre bien, essayer d'abord par vous m\u00eame avant de regarder les solutions). kattis : online judge que l'on va utiliser pour les comp\u00e9titions internes.","title":"Par o\u00f9 commencer ?"},{"location":"annonces/2022-07-11-coding-battle-2022/","text":"[11-juillet-2022] Bonjour \u00e0 tous . La prochaine \u00e9ch\u00e9ance de l'\u00e9quipe arrive \u00e0 grand pas. Les 12 et 13 Octobre 2022 se d\u00e9rouleront la sixi\u00e8me \u00e9dition du Shaker et sa Coding Battle. Je vous invite des \u00e0 pr\u00e9sent \u00e0 vous pr\u00e9-inscrire sur leur site pour ne pas rater l'inscription d\u00e9finitive. Pour nous y pr\u00e9parer au mieux. Nous allons organiser 3 \u00e0 4 s\u00e9ances de pr\u00e9paration : mini-cours + mise en situation d'ici la mi-Octobre. 1 en Juillet 2 en Septembre 1 d\u00e9but Octobre Pour la s\u00e9ance de ce mois de Juillet, vous allez travailler sur les probl\u00e8mes de la Coding Battle 2020 , puis pr\u00e9senterez vos solutions, vous soul\u00e8verez les difficult\u00e9, pour ensuite discuter des notions \u00e0 renforcer. Cette semaine vous aurez \u00e0 r\u00e9soudre le Weekly Challenge 01 . Avant la prochaine s\u00e9ance, qui se fera surement en distanciel \u00e0 la fin de cette semaine, vous devriez avoir traiter les probl\u00e8mes de la Coding Battle 2020 .","title":"Coding Battle 2022"},{"location":"annonces/2022-09-05-coding-battle-2022/","text":"[5-septembre-2022] Bonjour \u00e0 tous j'esp\u00e8re que tout le monde a pass\u00e9 un bel \u00e9t\u00e9 et de bonnes vacances . Nous allons reprendre les s\u00e9ances de pr\u00e9parations pour le Shaker qui arrivera tr\u00e8s vite : les 12 et 13 octobre 2022. Je m'adresse particuli\u00e8rement \u00e0 ceux qui veulent participer \u00e0 la Coding Battle de cette ann\u00e9e. Il faut imp\u00e9rativement que vous remplissez le formulaire de pr\u00e9inscription ici, pour ne pas rater l'inscription d\u00e9finitive qui arrivera tr\u00e8s prochainement. Le lien est ici . On va essayer programmer 3 \u00e0 4 s\u00e9ances de rencontre d'ici le concours. Je vous proposerai les dates sur Teams. Vous devriez vous organiser pour r\u00e9soudre au moins un petit set de trois probl\u00e8mes soit sur leetcode soit sur kattis par semaine. C'est important car m\u00eame si vous n'arriver pas encore \u00e0 les r\u00e9soudre, le plus important c'est d'avoir travaill\u00e9 dessus. Je vais vous les proposer dans la section Weekely Challenge. Voil\u00e0, pour tout compl\u00e9ment d'information n'h\u00e9sitez pas \u00e0 me contacter sur Teams ou par mail. Bonne reprise \u00e0 tous. Rado","title":"Reprise des s\u00e9ances"},{"location":"contenus/coding-battle-2020/","tags":["shaker","shaker 2020","training"],"text":"Coding battle 2020 Sujets Voici les sujets de l'\u00e9dition 2020 de la Coding Battle du Shaker : 6 probl\u00e8mes, 2h. Probl\u00e8me A: Billets \u00e0 prix d\u2019or. Probl\u00e8me B: Direction Top 50. Probl\u00e8me C: Tout le monde entend ? Probl\u00e8me D: Billet endommag\u00e9. Probl\u00e8me E: Le Bingo maudit. Probl\u00e8me F: Goodies en pagaille ! Consignes Prenez du temps pour traiter s\u00e9rieusement tous les probl\u00e8mes. Notez le nombre de probl\u00e8mes que vous avez r\u00e9ussi \u00e0 r\u00e9soudre en 2h. Notez le temps que vous avez mis \u00e0 r\u00e9soudre tous les probl\u00e8mes. Vous avez le droit de discuter entre vous mais chacun devra \u00e9crire son propre code. Vous devez \u00eatre en mesure d'expliquer votre solution. Vous avez le droit de vous documenter sur internet si vous \u00eates bloqu\u00e9s, sans pour autant rechercher les solutions des probl\u00e8mes.","title":"Coding battle 2020"},{"location":"contenus/coding-battle-2020/#coding-battle-2020","text":"","title":"Coding battle 2020"},{"location":"contenus/coding-battle-2020/#sujets","text":"Voici les sujets de l'\u00e9dition 2020 de la Coding Battle du Shaker : 6 probl\u00e8mes, 2h. Probl\u00e8me A: Billets \u00e0 prix d\u2019or. Probl\u00e8me B: Direction Top 50. Probl\u00e8me C: Tout le monde entend ? Probl\u00e8me D: Billet endommag\u00e9. Probl\u00e8me E: Le Bingo maudit. Probl\u00e8me F: Goodies en pagaille !","title":"Sujets"},{"location":"contenus/coding-battle-2020/#consignes","text":"Prenez du temps pour traiter s\u00e9rieusement tous les probl\u00e8mes. Notez le nombre de probl\u00e8mes que vous avez r\u00e9ussi \u00e0 r\u00e9soudre en 2h. Notez le temps que vous avez mis \u00e0 r\u00e9soudre tous les probl\u00e8mes. Vous avez le droit de discuter entre vous mais chacun devra \u00e9crire son propre code. Vous devez \u00eatre en mesure d'expliquer votre solution. Vous avez le droit de vous documenter sur internet si vous \u00eates bloqu\u00e9s, sans pour autant rechercher les solutions des probl\u00e8mes.","title":"Consignes"},{"location":"contenus/coding-battle-2021/","tags":["shaker","shaker 2021","training"],"text":"Coding battle 2021 Consignes Prenez du temps pour traiter s\u00e9rieusement tous les probl\u00e8mes. Notez le nombre de probl\u00e8mes que vous avez r\u00e9ussi \u00e0 r\u00e9soudre en 2h. Notez le temps que vous avez mis \u00e0 r\u00e9soudre tous les probl\u00e8mes. Vous avez le droit de discuter entre vous mais chacun devra \u00e9crire son propre code. Vous devez \u00eatre en mesure d'expliquer votre solution. Vous avez le droit de vous documenter sur internet si vous \u00eates bloqu\u00e9s, sans pour autant rechercher les solutions des probl\u00e8mes. Liste des probl\u00e8mes Voici les sujets de l'\u00e9dition 2021 de la Coding Battle du Shaker : 6 probl\u00e8mes, 2h. Une histoire de couleur Gros tas de bouquins Oh la belle prise Dans de beaux draps Un cad(re)eau empoisonn\u00e9 Estimation de toile Solutions Une histoire de couleur Nous voil\u00e0 \u00e0 la premi\u00e8re \u00e9preuve : la peinture. G\u00e9rard a oubli\u00e9 de commander la peinture. Il a pu trouver des restes dans son cabanon de jardin, mais ce n'est pas suffisant pour les besoins du concours et des artistes. Il aurait pu changer le th\u00e8me du concours en concours d'art minimaliste, mais non, parce que G\u00e9rard est ambitieux. Ainsi, il vous demandera de d\u00e9velopper un m\u00e9langeur de couleurs, un calculateur pour pr\u00e9voir \u00e0 l'avance les couleurs m\u00e9lang\u00e9es par les artistes. Dans le but d'\u00e9viter les m\u00e9langes inutiles et donc le gaspillage de peinture, votre mission est donc de calculer la couleur moyenne issue d'un m\u00e9lange de deux couleurs \\(C1\\) et \\(C2\\) . Les couleurs sont des entiers compris entre 0 et 255. Le r\u00e9sultat sera toujours entier et arrondi \u00e0 l'entier sup\u00e9rieur si n\u00e9cessaire. Entr\u00e9e Ligne 1, 2 : Sur les deux premi\u00e8res lignes, deux entiers \\(C1\\) et \\(C2\\) ( \\(0 \\leq C1,C2 \\leq 255\\) ) repr\u00e9sentant les deux couleurs \u00e0 m\u00e9langer. Sortie Afficher, sur une seule ligne, la valeur de la couleur obtenue, correspondant \u00e0 la moyenne des couleurs en entr\u00e9e, arrondie \u00e0 l'entier sup\u00e9rieur si n\u00e9cessaire. Tip Il s'agit de lire deux entiers sur l'entr\u00e9e standard et d'afficher leur moyenne (on attend un entier). En faisant attention \u00e0 bien afficher une moyenne enti\u00e8re. Si la somme est paire pas de soucis, sinon on ajoute 1 \u00e0 la somme pour avoir l'arrondi \u00e0 l'entier sup\u00e9rieur. 1 2 3 4 5 6 7 8 9 10 11 #include \"bits/stdc++.h\" using namespace std ; int main () { int a , b ; cin >> a >> b ; int c = ( a + b ) % 2 == 0 ? a + b : a + b + 1 ; cout << c / 2 << \" \\n \" ; return 0 ; } Gros tas de bouquins Nous voil\u00e0 \u00e0 la deuxi\u00e8me \u00e9preuve, l'\u00e9preuve de litt\u00e9rature. Les participants ont d\u00fb \u00e9crire un livre sur le th\u00e8me de leur choix, mais dans un temps imparti. Face \u00e0 la pile de livres grandissante et pour \u00e9viter un burn-out du jury (dont Gerard Traquenard), ces derniers ont d\u00e9cid\u00e9 de s'imposer un temps de lecture limite. Le jury de cette \u00e9preuve est compos\u00e9 de trois membres. Chaque membre a une sp\u00e9cialit\u00e9 et ne juge que sa sp\u00e9cialit\u00e9, et dispose d'un temps limite pour juger les livres. Il vous est donn\u00e9 le temps de lecture et le type pour chaque livre, vous devez indiquer si chaque jury aura le temps de lire tous les livres de sa sp\u00e9cialit\u00e9. Entr\u00e9e Ligne 1 : 3 entiers \\(TF\\) , \\(TP\\) et \\(TA\\) (avec \\(0 \\leq TF,TP,TA \\leq 10^6\\) ) les temps donn\u00e9s en minutes pour chaque jury, respectivement pour la cat\u00e9gorie de romans Fantastique, Policier, et Autre. Ligne 2 : Un entier \\(N\\) (avec \\(N\\geq 10^3\\) ) repr\u00e9sentant le nombre de romans \u00e0 lire. \\(N\\) lignes suivantes : S\u00e9par\u00e9s d'un espace, une lettre repr\u00e9sentant le type de roman (F pour fantastique, P pour policier, A pour autre) et un entier \\(t\\) repr\u00e9sentant le temps en minutes n\u00e9cessaire pour le lire. Sortie Une seule ligne avec \" oui \" si le jury a le temps de lire tous les livres, \" non \" sinon. Le jury a le temps de lire tous les livres si chaque membre du jury a le temps de lire tous les romans de sa sp\u00e9cialit\u00e9. Tip Il s'agit juste d'une boucle while qui tourne tant que les trois entiers \\(TF\\) , \\(TP\\) et \\(TA\\) sont positifs ou nuls, et qui \u00e0 chaque it\u00e9ration lit un temps de lecture \\(t\\) sur l'entr\u00e9e standard et d\u00e9cr\u00e9mete \\(TF\\) , \\(TP\\) et \\(TA\\) selon le type du roman lu. Si on sort de la boucle car on a tout lu, la r\u00e9ponse est \" oui \", sinon on est sorti car l'un des trois entiers de d\u00e9part est n\u00e9gatif. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \"bits/stdc++.h\" using namespace std ; int main () { int tf , tp , ta ; cin >> tf >> tp >> ta ; int n ; cin >> n ; int i = 0 ; while ( i < n && tf >= 0 && tp >= 0 && ta >= 0 ) { char type ; int t ; cin >> type >> t ; if ( type == 'F' ) { tf -= t ; } else if ( type == 'P' ) { tp -= t ; } else if ( type == 'A' ) { ta -= t ; } ++ i ; } if ( i == n ) cout << \"oui\" << \" \\n \" ; else cout << \"non\" << \" \\n \" ; return 0 ; } Oh la belle prise Apr\u00e8s avoir fini de ranger tous les livres, l'\u00e9preuve de photographie peut enfin commencer ! Cette fois, Gerard Traquenard a demand\u00e9 au grand Marcel Fauto, p\u00e9cheur du village de Rouffiac mais surtout photographe en herbe, d'organiser l'\u00e9preuve. Marcel a voulu aller \u00e0 l'essentiel, les r\u00e8gles sont donc plut\u00f4t simples : les diff\u00e9rents candidats vont devoir prendre une photo du paysage, et la meilleure photo gagnera l'\u00e9preuve. H\u00e9las avec des endroits magnifiques comme les eaux cristallines de l'Espinet ou encore la for\u00eat de Bonnal, les paysages du Cantal sont bien trop beaux, et les photographes n'arrivent pas \u00e0 trouver le clich\u00e9 parfait ! Le but pour gagner est, \u00e0 partir d'un paysage donn\u00e9, de trouver la (ou les) photos ayant le plus grand nombre de points d'int\u00e9r\u00eat. Les photos prises sont toutes au format carr\u00e9 de 3 par 3. Entr\u00e9e Ligne 1 : Deux entiers \\(H\\) et \\(L\\) (avec \\(3 \\leq H,L \\leq 100\\) ), correspondant respectivement \u00e0 la hauteur et \u00e0 la largeur du paysage. Lignes 2 \u00e0 \\(H+1\\) : Une cha\u00eene de \\(L\\) caract\u00e8res compos\u00e9e de \" - \" et de \" X \". Un \" X \" repr\u00e9sente un point d'int\u00e9r\u00eat, un \" - \" un point sans int\u00e9r\u00eat. Sortie Deux entiers \\(a\\) et \\(b\\) correspondant aux coordonn\u00e9es du coin haut gauche d'une photo de dimension 3 points par 3, contenant le plus de points d'int\u00e9r\u00eat possible. Si plusieurs photos ont le nombre maximum de points d'int\u00e9r\u00eat, vous pouvez renvoyer n'importe quelle photo maximisant le score. Remarques : \\(1 \\leq a \\leq H-2\\) et \\(1 \\leq b \\leq L-2\\) Le point haut gauche du paysage est aux coordonn\u00e9es \\((1, 1)\\) Tip Il s'agit de parcourir une matrice de taille \\(L \\times H\\) avec une fen\u00eatre de taille \\(3 \\times 3\\) et dans la fen\u00eatre compter le nombre de points d'int\u00e9r\u00eats. On intialise une variable stockant le max des points d'int\u00e9r\u00eats. Cette variable sera mise \u00e0 jour d\u00e8s que l'on change de fen\u00eatre. Pour mieux comprendre on peut par exemple g\u00e9n\u00e9rer toutes les coordonn\u00e9es des coins sup\u00e9rieur gauche des fen\u00eatres possibles en commen\u00e7ant par \\((1,1)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \"bits/stdc++.h\" using namespace std ; int main () { int h , l ; cin >> h >> l ; vector < string > p ( h ); for ( int i = 0 ; i < h ; i ++ ) { cin >> p [ i ]; } int max = 0 ; pair < int , int > ans = { -1 , -1 }; for ( int i = 0 ; i < h - 2 ; ++ i ) { for ( int j = 0 ; j < l - 2 ; ++ j ) { int pi = 0 ; for ( int k = i ; k < i + 3 ; ++ k ) { for ( int t = j ; t < j + 3 ; ++ t ) { if ( p [ k ][ t ] == 'X' ) pi ++ ; } } if ( max < pi ) { ans = { i , j }; } } } cout << ans . first + 1 << \" \" << ans . second + 1 << \" \\n \" ; return 0 ; } Dans de beaux draps Le sujet est ici . Tip Il faut commencer par convertir l'entr\u00e9e en une liste de points avec des coordonn\u00e9es \\((x, y)\\) ou \\((y, x)\\) comme vous voulez. Ensuite il vous faudra impl\u00e9menter une version twist\u00e9e d'un algorithme d'enveloppe convexe en 2D, vous avez le choix entre : le Graham Scan et le Jarvis Walk et autres ... Il faut g\u00e9rer toutefois le cas o\u00f9 les points du bas de la grille ne seront pas pris en compte (car il est plus opti de faire tomber le drap \u00e0 la verticale). Pour calculer la distance entre les points, il faut utiliser la distance euclidienne \\[ |AB| = \\sqrt{(x_B - x_A)^2 + (x_B - x_A)^2}. \\] Un cad(re)eau empoisonn\u00e9 Le sujet est ici . Tip Il s'agit d'un probl\u00e8me de parcours de graphe (d'arbre en particulier). Il vous faut impl\u00e9menter la bonne structure d'arbre : struct Node { int val ; vector < struct Node *> neighbors ; }; struct Tree { Node * root ; }; Ensuite l'algorithme qui nous int\u00e9resse est une adaptation de l'algorithme du Maximum Independent Set pour les arbres, ou le choix des noeuds se fait de tel sorte qu'il ont au plus un voisin dans l'ensemble choisi. Estimation de toile C'est la fin de la comp\u00e9tition ! Les gagnants ont eu leur prix et tout le monde repart satisfait du concours. Afin de faire du profit et profitant de la fatigue g\u00e9n\u00e9rale, Gerard souhaite r\u00e9cup\u00e9rer et vendre les \u0153uvres r\u00e9alis\u00e9es (sans l'accord des artistes, sacr\u00e9 G\u00e9rard). Il ne parvient qu'\u00e0 r\u00e9cup\u00e9rer les toiles de chacun, leur laissant sculptures et photos. Ensuite, il cherche \u00e0 regrouper les \u0153uvres en fonction de leur prix. D\u00e9brouillard comme il est, Gerard estime la valeur de ces \u0153uvres avec une formule qu'il a lui-m\u00eame invent\u00e9e : \\(V = A + P\\) (avec \\(V\\) = valeur de la toile en euros, \\(A\\) = aire de la toile en cm\u00b2 et \\(P\\) = p\u00e9rim\u00e8tre de la toile en cm). Mais \u00e9valuer les prix \u00e0 la main, c'est trop long pour Gerard, il voudrait bien avoir un prix fixe. Il pense d\u00e9j\u00e0 au prochain concours et aux diff\u00e9rents formats qui permettraient de vendre toutes les toiles au m\u00eame prix. Il cherche ainsi \u00e0 savoir, pour un prix donn\u00e9 par cette formule, combien de formats de toiles est-il possible d'avoir ? Entr\u00e9e Ligne 1 : Un entier \\(0 \\leq V \\leq 10^{15}\\) correspondant \u00e0 la valeur de la toile en euros. Sortie Le nombre de formats de toiles possibles. On notera que la permutation de la longueur et la largeur de la toile ne change pas le format de cette derni\u00e8re; par exemple, \\(20 \\times 25\\) et \\(25 \\times 20\\) repr\u00e9sentent le m\u00eame format. Tip Ce probl\u00e8me n'est pas aussi dur qu'il ne le para\u00eet : il faut trouver les dimensions \\(L\\) et \\(l\\) d'un rectangle v\u00e9rifiant : \\[ V = Ll + 2L + 2l \\] En tenant en compte que \\(V\\) peut \u00eatre tr\u00e8s grand (i.e. stocker la valeur dans un long long int par exemple). En r\u00e9arangeant un peu les choses on peut parvenir \u00e0 la relation suivante : \\[ V + 4 = (L + 2) \\times (l + 2) \\] En effet, sch\u00e9ma suivant nous permet de voir que \\(V + 4\\) est l'aire du rectangle de longueur \\(L + 2\\) et de largeur \\(l + 2\\) . Il reste alors \u00e0 trouver deux entiers \\(L\\) et \\(l\\) qui satisfont cette nouvelle relation. L 2 +--------+----+ l | | | l | A | 2l | +--------+----+ 2 | 2L | 4 | 2 +--------+----+ L 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \"bits/stdc++.h\" using namespace std ; int main () { long long int v ; cin >> v ; long long int a , b ; // Une fois le carr\u00e9 atteint, on a les m\u00eames valeurs // mais dans l'ordre inverse for ( int i = 3 ; i < sqrt ( v + 4 ); ++ i ) { if (( v + 4 ) % i == 0 ) { a = i - 2 ; b = (( v + 4 ) / i ) - 2 ; cout << a << \" \" << b << endl ; } } return 0 ; }","title":"Coding battle 2021"},{"location":"contenus/coding-battle-2021/#coding-battle-2021","text":"","title":"Coding battle 2021"},{"location":"contenus/coding-battle-2021/#consignes","text":"Prenez du temps pour traiter s\u00e9rieusement tous les probl\u00e8mes. Notez le nombre de probl\u00e8mes que vous avez r\u00e9ussi \u00e0 r\u00e9soudre en 2h. Notez le temps que vous avez mis \u00e0 r\u00e9soudre tous les probl\u00e8mes. Vous avez le droit de discuter entre vous mais chacun devra \u00e9crire son propre code. Vous devez \u00eatre en mesure d'expliquer votre solution. Vous avez le droit de vous documenter sur internet si vous \u00eates bloqu\u00e9s, sans pour autant rechercher les solutions des probl\u00e8mes.","title":"Consignes"},{"location":"contenus/coding-battle-2021/#liste-des-problemes","text":"Voici les sujets de l'\u00e9dition 2021 de la Coding Battle du Shaker : 6 probl\u00e8mes, 2h. Une histoire de couleur Gros tas de bouquins Oh la belle prise Dans de beaux draps Un cad(re)eau empoisonn\u00e9 Estimation de toile","title":"Liste des probl\u00e8mes"},{"location":"contenus/coding-battle-2021/#solutions","text":"","title":"Solutions"},{"location":"contenus/coding-battle-2021/#une-histoire-de-couleur","text":"Nous voil\u00e0 \u00e0 la premi\u00e8re \u00e9preuve : la peinture. G\u00e9rard a oubli\u00e9 de commander la peinture. Il a pu trouver des restes dans son cabanon de jardin, mais ce n'est pas suffisant pour les besoins du concours et des artistes. Il aurait pu changer le th\u00e8me du concours en concours d'art minimaliste, mais non, parce que G\u00e9rard est ambitieux. Ainsi, il vous demandera de d\u00e9velopper un m\u00e9langeur de couleurs, un calculateur pour pr\u00e9voir \u00e0 l'avance les couleurs m\u00e9lang\u00e9es par les artistes. Dans le but d'\u00e9viter les m\u00e9langes inutiles et donc le gaspillage de peinture, votre mission est donc de calculer la couleur moyenne issue d'un m\u00e9lange de deux couleurs \\(C1\\) et \\(C2\\) . Les couleurs sont des entiers compris entre 0 et 255. Le r\u00e9sultat sera toujours entier et arrondi \u00e0 l'entier sup\u00e9rieur si n\u00e9cessaire. Entr\u00e9e Ligne 1, 2 : Sur les deux premi\u00e8res lignes, deux entiers \\(C1\\) et \\(C2\\) ( \\(0 \\leq C1,C2 \\leq 255\\) ) repr\u00e9sentant les deux couleurs \u00e0 m\u00e9langer. Sortie Afficher, sur une seule ligne, la valeur de la couleur obtenue, correspondant \u00e0 la moyenne des couleurs en entr\u00e9e, arrondie \u00e0 l'entier sup\u00e9rieur si n\u00e9cessaire. Tip Il s'agit de lire deux entiers sur l'entr\u00e9e standard et d'afficher leur moyenne (on attend un entier). En faisant attention \u00e0 bien afficher une moyenne enti\u00e8re. Si la somme est paire pas de soucis, sinon on ajoute 1 \u00e0 la somme pour avoir l'arrondi \u00e0 l'entier sup\u00e9rieur. 1 2 3 4 5 6 7 8 9 10 11 #include \"bits/stdc++.h\" using namespace std ; int main () { int a , b ; cin >> a >> b ; int c = ( a + b ) % 2 == 0 ? a + b : a + b + 1 ; cout << c / 2 << \" \\n \" ; return 0 ; }","title":"Une histoire de couleur"},{"location":"contenus/coding-battle-2021/#gros-tas-de-bouquins","text":"Nous voil\u00e0 \u00e0 la deuxi\u00e8me \u00e9preuve, l'\u00e9preuve de litt\u00e9rature. Les participants ont d\u00fb \u00e9crire un livre sur le th\u00e8me de leur choix, mais dans un temps imparti. Face \u00e0 la pile de livres grandissante et pour \u00e9viter un burn-out du jury (dont Gerard Traquenard), ces derniers ont d\u00e9cid\u00e9 de s'imposer un temps de lecture limite. Le jury de cette \u00e9preuve est compos\u00e9 de trois membres. Chaque membre a une sp\u00e9cialit\u00e9 et ne juge que sa sp\u00e9cialit\u00e9, et dispose d'un temps limite pour juger les livres. Il vous est donn\u00e9 le temps de lecture et le type pour chaque livre, vous devez indiquer si chaque jury aura le temps de lire tous les livres de sa sp\u00e9cialit\u00e9. Entr\u00e9e Ligne 1 : 3 entiers \\(TF\\) , \\(TP\\) et \\(TA\\) (avec \\(0 \\leq TF,TP,TA \\leq 10^6\\) ) les temps donn\u00e9s en minutes pour chaque jury, respectivement pour la cat\u00e9gorie de romans Fantastique, Policier, et Autre. Ligne 2 : Un entier \\(N\\) (avec \\(N\\geq 10^3\\) ) repr\u00e9sentant le nombre de romans \u00e0 lire. \\(N\\) lignes suivantes : S\u00e9par\u00e9s d'un espace, une lettre repr\u00e9sentant le type de roman (F pour fantastique, P pour policier, A pour autre) et un entier \\(t\\) repr\u00e9sentant le temps en minutes n\u00e9cessaire pour le lire. Sortie Une seule ligne avec \" oui \" si le jury a le temps de lire tous les livres, \" non \" sinon. Le jury a le temps de lire tous les livres si chaque membre du jury a le temps de lire tous les romans de sa sp\u00e9cialit\u00e9. Tip Il s'agit juste d'une boucle while qui tourne tant que les trois entiers \\(TF\\) , \\(TP\\) et \\(TA\\) sont positifs ou nuls, et qui \u00e0 chaque it\u00e9ration lit un temps de lecture \\(t\\) sur l'entr\u00e9e standard et d\u00e9cr\u00e9mete \\(TF\\) , \\(TP\\) et \\(TA\\) selon le type du roman lu. Si on sort de la boucle car on a tout lu, la r\u00e9ponse est \" oui \", sinon on est sorti car l'un des trois entiers de d\u00e9part est n\u00e9gatif. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \"bits/stdc++.h\" using namespace std ; int main () { int tf , tp , ta ; cin >> tf >> tp >> ta ; int n ; cin >> n ; int i = 0 ; while ( i < n && tf >= 0 && tp >= 0 && ta >= 0 ) { char type ; int t ; cin >> type >> t ; if ( type == 'F' ) { tf -= t ; } else if ( type == 'P' ) { tp -= t ; } else if ( type == 'A' ) { ta -= t ; } ++ i ; } if ( i == n ) cout << \"oui\" << \" \\n \" ; else cout << \"non\" << \" \\n \" ; return 0 ; }","title":"Gros tas de bouquins"},{"location":"contenus/coding-battle-2021/#oh-la-belle-prise","text":"Apr\u00e8s avoir fini de ranger tous les livres, l'\u00e9preuve de photographie peut enfin commencer ! Cette fois, Gerard Traquenard a demand\u00e9 au grand Marcel Fauto, p\u00e9cheur du village de Rouffiac mais surtout photographe en herbe, d'organiser l'\u00e9preuve. Marcel a voulu aller \u00e0 l'essentiel, les r\u00e8gles sont donc plut\u00f4t simples : les diff\u00e9rents candidats vont devoir prendre une photo du paysage, et la meilleure photo gagnera l'\u00e9preuve. H\u00e9las avec des endroits magnifiques comme les eaux cristallines de l'Espinet ou encore la for\u00eat de Bonnal, les paysages du Cantal sont bien trop beaux, et les photographes n'arrivent pas \u00e0 trouver le clich\u00e9 parfait ! Le but pour gagner est, \u00e0 partir d'un paysage donn\u00e9, de trouver la (ou les) photos ayant le plus grand nombre de points d'int\u00e9r\u00eat. Les photos prises sont toutes au format carr\u00e9 de 3 par 3. Entr\u00e9e Ligne 1 : Deux entiers \\(H\\) et \\(L\\) (avec \\(3 \\leq H,L \\leq 100\\) ), correspondant respectivement \u00e0 la hauteur et \u00e0 la largeur du paysage. Lignes 2 \u00e0 \\(H+1\\) : Une cha\u00eene de \\(L\\) caract\u00e8res compos\u00e9e de \" - \" et de \" X \". Un \" X \" repr\u00e9sente un point d'int\u00e9r\u00eat, un \" - \" un point sans int\u00e9r\u00eat. Sortie Deux entiers \\(a\\) et \\(b\\) correspondant aux coordonn\u00e9es du coin haut gauche d'une photo de dimension 3 points par 3, contenant le plus de points d'int\u00e9r\u00eat possible. Si plusieurs photos ont le nombre maximum de points d'int\u00e9r\u00eat, vous pouvez renvoyer n'importe quelle photo maximisant le score. Remarques : \\(1 \\leq a \\leq H-2\\) et \\(1 \\leq b \\leq L-2\\) Le point haut gauche du paysage est aux coordonn\u00e9es \\((1, 1)\\) Tip Il s'agit de parcourir une matrice de taille \\(L \\times H\\) avec une fen\u00eatre de taille \\(3 \\times 3\\) et dans la fen\u00eatre compter le nombre de points d'int\u00e9r\u00eats. On intialise une variable stockant le max des points d'int\u00e9r\u00eats. Cette variable sera mise \u00e0 jour d\u00e8s que l'on change de fen\u00eatre. Pour mieux comprendre on peut par exemple g\u00e9n\u00e9rer toutes les coordonn\u00e9es des coins sup\u00e9rieur gauche des fen\u00eatres possibles en commen\u00e7ant par \\((1,1)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \"bits/stdc++.h\" using namespace std ; int main () { int h , l ; cin >> h >> l ; vector < string > p ( h ); for ( int i = 0 ; i < h ; i ++ ) { cin >> p [ i ]; } int max = 0 ; pair < int , int > ans = { -1 , -1 }; for ( int i = 0 ; i < h - 2 ; ++ i ) { for ( int j = 0 ; j < l - 2 ; ++ j ) { int pi = 0 ; for ( int k = i ; k < i + 3 ; ++ k ) { for ( int t = j ; t < j + 3 ; ++ t ) { if ( p [ k ][ t ] == 'X' ) pi ++ ; } } if ( max < pi ) { ans = { i , j }; } } } cout << ans . first + 1 << \" \" << ans . second + 1 << \" \\n \" ; return 0 ; }","title":"Oh la belle prise"},{"location":"contenus/coding-battle-2021/#dans-de-beaux-draps","text":"Le sujet est ici . Tip Il faut commencer par convertir l'entr\u00e9e en une liste de points avec des coordonn\u00e9es \\((x, y)\\) ou \\((y, x)\\) comme vous voulez. Ensuite il vous faudra impl\u00e9menter une version twist\u00e9e d'un algorithme d'enveloppe convexe en 2D, vous avez le choix entre : le Graham Scan et le Jarvis Walk et autres ... Il faut g\u00e9rer toutefois le cas o\u00f9 les points du bas de la grille ne seront pas pris en compte (car il est plus opti de faire tomber le drap \u00e0 la verticale). Pour calculer la distance entre les points, il faut utiliser la distance euclidienne \\[ |AB| = \\sqrt{(x_B - x_A)^2 + (x_B - x_A)^2}. \\]","title":"Dans de beaux draps"},{"location":"contenus/coding-battle-2021/#un-cadreeau-empoisonne","text":"Le sujet est ici . Tip Il s'agit d'un probl\u00e8me de parcours de graphe (d'arbre en particulier). Il vous faut impl\u00e9menter la bonne structure d'arbre : struct Node { int val ; vector < struct Node *> neighbors ; }; struct Tree { Node * root ; }; Ensuite l'algorithme qui nous int\u00e9resse est une adaptation de l'algorithme du Maximum Independent Set pour les arbres, ou le choix des noeuds se fait de tel sorte qu'il ont au plus un voisin dans l'ensemble choisi.","title":"Un cad(re)eau empoisonn\u00e9"},{"location":"contenus/coding-battle-2021/#estimation-de-toile","text":"C'est la fin de la comp\u00e9tition ! Les gagnants ont eu leur prix et tout le monde repart satisfait du concours. Afin de faire du profit et profitant de la fatigue g\u00e9n\u00e9rale, Gerard souhaite r\u00e9cup\u00e9rer et vendre les \u0153uvres r\u00e9alis\u00e9es (sans l'accord des artistes, sacr\u00e9 G\u00e9rard). Il ne parvient qu'\u00e0 r\u00e9cup\u00e9rer les toiles de chacun, leur laissant sculptures et photos. Ensuite, il cherche \u00e0 regrouper les \u0153uvres en fonction de leur prix. D\u00e9brouillard comme il est, Gerard estime la valeur de ces \u0153uvres avec une formule qu'il a lui-m\u00eame invent\u00e9e : \\(V = A + P\\) (avec \\(V\\) = valeur de la toile en euros, \\(A\\) = aire de la toile en cm\u00b2 et \\(P\\) = p\u00e9rim\u00e8tre de la toile en cm). Mais \u00e9valuer les prix \u00e0 la main, c'est trop long pour Gerard, il voudrait bien avoir un prix fixe. Il pense d\u00e9j\u00e0 au prochain concours et aux diff\u00e9rents formats qui permettraient de vendre toutes les toiles au m\u00eame prix. Il cherche ainsi \u00e0 savoir, pour un prix donn\u00e9 par cette formule, combien de formats de toiles est-il possible d'avoir ? Entr\u00e9e Ligne 1 : Un entier \\(0 \\leq V \\leq 10^{15}\\) correspondant \u00e0 la valeur de la toile en euros. Sortie Le nombre de formats de toiles possibles. On notera que la permutation de la longueur et la largeur de la toile ne change pas le format de cette derni\u00e8re; par exemple, \\(20 \\times 25\\) et \\(25 \\times 20\\) repr\u00e9sentent le m\u00eame format. Tip Ce probl\u00e8me n'est pas aussi dur qu'il ne le para\u00eet : il faut trouver les dimensions \\(L\\) et \\(l\\) d'un rectangle v\u00e9rifiant : \\[ V = Ll + 2L + 2l \\] En tenant en compte que \\(V\\) peut \u00eatre tr\u00e8s grand (i.e. stocker la valeur dans un long long int par exemple). En r\u00e9arangeant un peu les choses on peut parvenir \u00e0 la relation suivante : \\[ V + 4 = (L + 2) \\times (l + 2) \\] En effet, sch\u00e9ma suivant nous permet de voir que \\(V + 4\\) est l'aire du rectangle de longueur \\(L + 2\\) et de largeur \\(l + 2\\) . Il reste alors \u00e0 trouver deux entiers \\(L\\) et \\(l\\) qui satisfont cette nouvelle relation. L 2 +--------+----+ l | | | l | A | 2l | +--------+----+ 2 | 2L | 4 | 2 +--------+----+ L 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \"bits/stdc++.h\" using namespace std ; int main () { long long int v ; cin >> v ; long long int a , b ; // Une fois le carr\u00e9 atteint, on a les m\u00eames valeurs // mais dans l'ordre inverse for ( int i = 3 ; i < sqrt ( v + 4 ); ++ i ) { if (( v + 4 ) % i == 0 ) { a = i - 2 ; b = (( v + 4 ) / i ) - 2 ; cout << a << \" \" << b << endl ; } } return 0 ; }","title":"Estimation de toile"},{"location":"contenus/mini-cours/conteneurs-c-plus-plus/","text":"Collections Une collection regroupe un nombre arbitraire d'\u00e9l\u00e9ments de m\u00eame type . La complexit\u00e9 des op\u00e9ration varie suivant la collection : acc\u00e8s au \\(n\\) -\u00e8me \u00e9l\u00e9ment rechercher un \u00e9l\u00e9ment ajouter un \u00e9l\u00e9ment \u00e0 une position arbitraire supprimer un \u00e9l\u00e9ment parcourir les \u00e9l\u00e9ments dans l'ordre En particulier les tableaux associatifs peuvent \u00eatre vus comme des collections de paires (cl\u00e9, valeur). Il est primordiale de choisir la collection adapt\u00e9e pour chaque probl\u00e8me. Collections en C++ Toutes les collections sont dans l'espace de nom std . Toujours \u00e9crire using namespace std; . Certaines collections ( stack , queue , priority_queue ) sont des adapteurs qui utilisent plusieurs classes comme impl\u00e9mentation ( list , vector , ...).","title":"Conteneurs de la biblioth\u00e8que standard C++"},{"location":"contenus/mini-cours/conteneurs-c-plus-plus/#collections","text":"Une collection regroupe un nombre arbitraire d'\u00e9l\u00e9ments de m\u00eame type . La complexit\u00e9 des op\u00e9ration varie suivant la collection : acc\u00e8s au \\(n\\) -\u00e8me \u00e9l\u00e9ment rechercher un \u00e9l\u00e9ment ajouter un \u00e9l\u00e9ment \u00e0 une position arbitraire supprimer un \u00e9l\u00e9ment parcourir les \u00e9l\u00e9ments dans l'ordre En particulier les tableaux associatifs peuvent \u00eatre vus comme des collections de paires (cl\u00e9, valeur). Il est primordiale de choisir la collection adapt\u00e9e pour chaque probl\u00e8me.","title":"Collections"},{"location":"contenus/mini-cours/conteneurs-c-plus-plus/#collections-en-c","text":"Toutes les collections sont dans l'espace de nom std . Toujours \u00e9crire using namespace std; . Certaines collections ( stack , queue , priority_queue ) sont des adapteurs qui utilisent plusieurs classes comme impl\u00e9mentation ( list , vector , ...).","title":"Collections en C++"},{"location":"contenus/mini-cours/modele-code/","text":"Mod\u00e8le de code C++ Voici un mod\u00e8le de code C++ typique pour la programmation comp\u00e9titive. exemple.cpp 1 2 3 4 5 6 7 8 9 #include <bits/stdc++.h> using namespace std ; int main () { // solution comes here return 0 ; } \u00c0 la ligne 1, #include <bits/stdc++.h> permet d'inclure toute la biblioth\u00e8que standard de C++, ainsi il n'est plus n\u00e9cessaire d'inclure individuellement les biblioth\u00e8ques comme iostream ou vector ... La directive using namespace std; permet d'utiliser directement toutes les collections et les fonctions pr\u00e9sentes dans la biblioth\u00e8que standard dans le code. Sans cette ligne, il est n\u00e9cessaire de sp\u00e9cifier \u00e0 chaque fois l'espace de nom de la collection ou de la fonction. Par exemple avec cette directive au lieu d'\u00e9crire std::cout , on peut directement \u00e9crire cout . Ensuite voici un exemple de ligne de commande pour compiler exemple.py en l'ex\u00e9cutable run . g++ -std=c++17 -Wall -O2 -o run exemple.cpp Le compilateur g++ va suivre le standard C++17 ( -std=c++17 ), va optimiser le code ( -O2 ) et va afficher toute les erreurs/avertissements possibles ( -Wall ).","title":"Mod\u00e8le de code C++"},{"location":"contenus/mini-cours/modele-code/#modele-de-code-c","text":"Voici un mod\u00e8le de code C++ typique pour la programmation comp\u00e9titive. exemple.cpp 1 2 3 4 5 6 7 8 9 #include <bits/stdc++.h> using namespace std ; int main () { // solution comes here return 0 ; } \u00c0 la ligne 1, #include <bits/stdc++.h> permet d'inclure toute la biblioth\u00e8que standard de C++, ainsi il n'est plus n\u00e9cessaire d'inclure individuellement les biblioth\u00e8ques comme iostream ou vector ... La directive using namespace std; permet d'utiliser directement toutes les collections et les fonctions pr\u00e9sentes dans la biblioth\u00e8que standard dans le code. Sans cette ligne, il est n\u00e9cessaire de sp\u00e9cifier \u00e0 chaque fois l'espace de nom de la collection ou de la fonction. Par exemple avec cette directive au lieu d'\u00e9crire std::cout , on peut directement \u00e9crire cout . Ensuite voici un exemple de ligne de commande pour compiler exemple.py en l'ex\u00e9cutable run . g++ -std=c++17 -Wall -O2 -o run exemple.cpp Le compilateur g++ va suivre le standard C++17 ( -std=c++17 ), va optimiser le code ( -O2 ) et va afficher toute les erreurs/avertissements possibles ( -Wall ).","title":"Mod\u00e8le de code C++"},{"location":"contenus/seances/2022-07-18-notes/","text":"","title":"2022 07 18 notes"},{"location":"contenus/seances/2022-07-18/","text":"Discussion Coding Battle du Shaker 2020 R\u00e9cursion Consiste \u00e0 r\u00e9soudre un probl\u00e8me informellement de la mani\u00e8re suivante : Si l'instance courante peut \u00eatre directement r\u00e9solue, alors il faut directement la r\u00e9soudre. Sinon, la r\u00e9duire \u00e0 une instance plus petite du m\u00eame probl\u00e8me. On doit avoir un nombre fini d'appels r\u00e9cursifs lors de la r\u00e9solution d'instance plus petite. Comme un appel r\u00e9cursif conduit \u00e0 la r\u00e9solution d'une instance plus petite, on arrivera n\u00e9cessairement \u00e0 une instance \u00e9l\u00e9mentaire appel\u00e9e cas de base (il s'agit de la plus petite instance possible du probl\u00e8me) qui doit pouvoir \u00eatre r\u00e9solue d'une diff\u00e9rente mani\u00e8re. Fibonacci La fonction \\(F\\) suivante calcule le \\(n\\) -\u00e8me nombre de Fibonacci : \\[ \\begin{align} F(0) & = 0\\\\ F(1) & = 1\\\\ F(n) & = F(n-1) + F(n-2) \\mbox{ } \\forall n \\geq 2. \\end{align} \\] La r\u00e9solution de l'instance de taille \\(n\\) n\u00e9cessite la r\u00e9solution des instances de taille \\((n-1)\\) et \\((n-2)\\) . En pseudo-code, nous avons l'algorithme suivant : F(n) : if n <= 1 then : return n else : return F(n-1) + F(n-2) Arbre de r\u00e9cursion Voici l'arbre des appels r\u00e9cursifs \u00e0 la fonction \\(F\\) pour le calcul de \\(F(4)\\) . flowchart TD A[\"F(4)\"]-->B[\"F(3)\"]; A --> C[\"F(2)\"]; B --> D[\"F(2)\"]; B --> E[\"F(1)\"]:::basecase; C --> F[\"F(1)\"]:::basecase; C --> G[\"F(0)\"]:::basecase; D --> H[\"F(1)\"]:::basecase; D --> I[\"F(0)\"]:::basecase; classDef basecase fill:#f96;","title":"S\u00e9ance du 18 Juillet 2022"},{"location":"contenus/seances/2022-07-18/#discussion-coding-battle-du-shaker-2020","text":"","title":"Discussion Coding Battle du Shaker 2020"},{"location":"contenus/seances/2022-07-18/#recursion","text":"Consiste \u00e0 r\u00e9soudre un probl\u00e8me informellement de la mani\u00e8re suivante : Si l'instance courante peut \u00eatre directement r\u00e9solue, alors il faut directement la r\u00e9soudre. Sinon, la r\u00e9duire \u00e0 une instance plus petite du m\u00eame probl\u00e8me. On doit avoir un nombre fini d'appels r\u00e9cursifs lors de la r\u00e9solution d'instance plus petite. Comme un appel r\u00e9cursif conduit \u00e0 la r\u00e9solution d'une instance plus petite, on arrivera n\u00e9cessairement \u00e0 une instance \u00e9l\u00e9mentaire appel\u00e9e cas de base (il s'agit de la plus petite instance possible du probl\u00e8me) qui doit pouvoir \u00eatre r\u00e9solue d'une diff\u00e9rente mani\u00e8re.","title":"R\u00e9cursion"},{"location":"contenus/seances/2022-07-18/#fibonacci","text":"La fonction \\(F\\) suivante calcule le \\(n\\) -\u00e8me nombre de Fibonacci : \\[ \\begin{align} F(0) & = 0\\\\ F(1) & = 1\\\\ F(n) & = F(n-1) + F(n-2) \\mbox{ } \\forall n \\geq 2. \\end{align} \\] La r\u00e9solution de l'instance de taille \\(n\\) n\u00e9cessite la r\u00e9solution des instances de taille \\((n-1)\\) et \\((n-2)\\) . En pseudo-code, nous avons l'algorithme suivant : F(n) : if n <= 1 then : return n else : return F(n-1) + F(n-2)","title":"Fibonacci"},{"location":"contenus/seances/2022-07-18/#arbre-de-recursion","text":"Voici l'arbre des appels r\u00e9cursifs \u00e0 la fonction \\(F\\) pour le calcul de \\(F(4)\\) . flowchart TD A[\"F(4)\"]-->B[\"F(3)\"]; A --> C[\"F(2)\"]; B --> D[\"F(2)\"]; B --> E[\"F(1)\"]:::basecase; C --> F[\"F(1)\"]:::basecase; C --> G[\"F(0)\"]:::basecase; D --> H[\"F(1)\"]:::basecase; D --> I[\"F(0)\"]:::basecase; classDef basecase fill:#f96;","title":"Arbre de r\u00e9cursion"},{"location":"contenus/weekly-challenges/05-septembre-2022/","tags":["data structure","dynamic programming","math"],"text":"Weekly Challenge 02 Probl\u00e8mes Key Board Row Coin Change A Furious Cocktail Solutions \u00c0 venir Consignes Les probl\u00e8mes sont \u00e0 traiter et \u00e0 soumettre sur leetcode ou sur kattis .","title":"Weekly Challenge 02"},{"location":"contenus/weekly-challenges/05-septembre-2022/#weekly-challenge-02","text":"","title":"Weekly Challenge 02"},{"location":"contenus/weekly-challenges/05-septembre-2022/#problemes","text":"Key Board Row Coin Change A Furious Cocktail","title":"Probl\u00e8mes"},{"location":"contenus/weekly-challenges/05-septembre-2022/#solutions","text":"\u00c0 venir","title":"Solutions"},{"location":"contenus/weekly-challenges/05-septembre-2022/#consignes","text":"Les probl\u00e8mes sont \u00e0 traiter et \u00e0 soumettre sur leetcode ou sur kattis .","title":"Consignes"},{"location":"contenus/weekly-challenges/11-juillet-2022/","tags":["easy","two pointers","binary search","array","math"],"text":"Weekly Challenge 01 Probl\u00e8mes Two sum Plus one First bad version Solutions \u00c0 venir Consignes Les probl\u00e8mes sont \u00e0 traiter et \u00e0 soumettre sur leetcode .","title":"Weekly Challenge 01"},{"location":"contenus/weekly-challenges/11-juillet-2022/#weekly-challenge-01","text":"","title":"Weekly Challenge 01"},{"location":"contenus/weekly-challenges/11-juillet-2022/#problemes","text":"Two sum Plus one First bad version","title":"Probl\u00e8mes"},{"location":"contenus/weekly-challenges/11-juillet-2022/#solutions","text":"\u00c0 venir","title":"Solutions"},{"location":"contenus/weekly-challenges/11-juillet-2022/#consignes","text":"Les probl\u00e8mes sont \u00e0 traiter et \u00e0 soumettre sur leetcode .","title":"Consignes"}]}